<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body,
  model-viewer {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
  }
</style>
<script type="module" src="model-viewer.min.js" defer></script>
<!-- body -->

<script>
  let canvasTexture = null;

  // always call this in the code,
  // because we want to get the original one everytime
  function getModelViewer() {
    return document.getElementById('modelViewer');
  }

  let bgColorDefault = "#ffffff";
  let textColorDefault = "#000000";
  const defaultImageWidth = 100;
  const defaultImageHeight = 100;

  const canvasSize = 1024;
  const imageId = "image-print";

  let pendingCanvasUpdate = null;


  function getCanvasTexture() {
    if (canvasTexture) return canvasTexture;
    console.log("Creating new canvas texture");
    const modelViewer = getModelViewer();
    canvasTexture = modelViewer.createCanvasTexture();
    updateCanvasTexture1();
    return canvasTexture;
  }

  function updateCanvasTexture1(
    customText,
    color,
    backgroundColor,
    fontSize,
    textX,
    textY,
    texture,
    rotation,
    imageSrc,
    imageRotation,
    imageX,
    imageY
  ) {
    pendingCanvasUpdate = {
      customText,
      color,
      backgroundColor,
      fontSize,
      textX,
      textY,
      texture,
      rotation,
      imageSrc,
      imageRotation,
      imageX,
      imageY
    };
    requestAnimationFrame(updateModel);
  }

  function updateModel() {
    if (!pendingCanvasUpdate) return;

    const {
      customText,
      color,
      backgroundColor,
      fontSize,
      textX,
      textY,
      texture,
      rotation,
      imageSrc,
      imageRotation,
      imageX,
      imageY
    } = pendingCanvasUpdate;

    pendingCanvasUpdate = null;

    const canvas = canvasTexture ? canvasTexture.source.element : document.createElement('canvas');
    const offscreenCanvas = canvas.offscreenCanvas;
    const ctx = canvas.getContext('2d');
    console.log("offscreen canvas: ", canvas.offscreenCanvas);
    // log image rotation, x and y
    console.log("Image rotation: ", imageRotation);
    console.log("Image x: ", imageX);
    console.log("Image y: ", imageY);

    ctx.fillStyle = backgroundColor || bgColorDefault;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (imageSrc) {
      console.log("Image source provided");
      const image = new Image(defaultImageWidth, defaultImageHeight);
      // set image id
      image.onload = function () {
        console.log("Image loaded");
        ctx.save();
        // Calculate the center point of the image
        const centerX = 60 + (imageX || 0) + defaultImageWidth / 2;
        const centerY = 96 * (canvas.height / 512) + (imageY || 0);

        // Translate to the center of the image
        ctx.translate(centerX, centerY);

        // Rotate around this center point
        ctx.rotate((imageRotation || 0) * Math.PI / 180);

        // Scale to flip vertically (if needed)
        ctx.scale(1, -1);

        // Draw the image centered on this point
        ctx.drawImage(
          image,
          -defaultImageWidth / 2,
          -defaultImageHeight / 2,
          defaultImageWidth,
          defaultImageHeight
        );
        ctx.restore();

        if (customText != null) {
          drawText(canvas, customText, color, fontSize, textX, textY, rotation);
        }

        if (texture) updateTexture(texture);

        if (canvasTexture) {
          console.log("Updating canvas texture source 1");
          canvasTexture.source.update();
        }
      }
      image.onerror = function () {
        console.error("Image load error");
        if (customText != null) {
          drawText(canvas, customText, color, fontSize, textX, textY, rotation);
        }

        if (texture) updateTexture(texture);

        if (canvasTexture) {
          console.log("Updating canvas texture source 1");
          canvasTexture.source.update();
        }
      }
      image.src = imageSrc;
    }
    console.log("drawing text if required");
    if (customText != null) {
      drawText(canvas, customText, color, fontSize, textX, textY, rotation);
    }

    if (texture) updateTexture(texture);

    if (canvasTexture) {
      console.log("Updating canvas texture source 1");
      canvasTexture.source.update();
    }

  }

  function drawText(canvas, customText, color, fontSize, textX, textY, rotation) {
    const ctx = canvas.getContext('2d');

    ctx.save();

    const baseFontSize = fontSize || 24;
    const adjustedFontSize = baseFontSize * (canvas.width / 512); // Scale font size based on canvas size
    ctx.font = `${adjustedFontSize}px Arial, sans-serif`;

    // Measure text dimensions
    const textMetrics = ctx.measureText(customText);
    const textWidth = textMetrics.width;
    const textHeight = adjustedFontSize; // Approximate height based on font size

    // Calculate the position where the text should be placed
    const posX = (textX != null ? textX : 0) * (canvas.width / 512);
    const posY = (textY != null ? textY : 0) * (canvas.height / 512);

    // Move to the desired position
    ctx.translate(
      posX + 35 * (canvas.width / 512) + textWidth / 2,
      posY + 86 * (canvas.height / 512)
    );

    //flip vertically 
    ctx.scale(1, -1);

    // Apply rotation
    ctx.rotate((rotation || 0) * Math.PI / 180);

    // Set text alignment and baseline
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Enable image smoothing
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";


    // Set fill style
    ctx.fillStyle = color || textColorDefault;

    // Draw the text at (0, 0)
    ctx.fillText(customText, 0, 0);

    ctx.restore();
  }

  function updateTexture(texture) {
    const modelViewer = getModelViewer();
    const material = modelViewer.model.materials[0];
    const {baseColorTexture} = material.pbrMetallicRoughness;

    console.log("Texture type changed to:", texture);
    switch (texture) {
      case "none":
        baseColorTexture.setTexture(null);
        break;
      case "text":
        baseColorTexture.setTexture(getCanvasTexture());
        break;
    }
  }

  function initializeModelViewer() {
    console.log("Initializing Model Viewer");

    canvasTexture = null; // resetting canvas texture here every time we open a new model

    const modelViewer = getModelViewer();

    if (!modelViewer) {
      console.error("Model viewer element not found");
      return;
    }

    // log device pixel ratio
    console.log("Device pixel ratio:", window.devicePixelRatio);

    modelViewer.addEventListener("load", async () => {
      console.log("Model viewer loaded");
      const material = modelViewer.model.materials[0];

      // Initialize canvas texture
      canvasTexture = modelViewer.createCanvasTexture();

      const offscreenCanvas = document.createElement('canvas');
      adjustCanvasResolution(offscreenCanvas);
      canvasTexture.source.element.offscreenCanvas = offscreenCanvas;


      adjustCanvasResolution(canvasTexture.source.element);
    });

    modelViewer.addEventListener("error", (error) => {
      console.error("Model viewer error:", error);
    });
  }

  // Function to adjust the canvas resolution dynamically
  // most of this is hardcoded because no time for better investigation
  function adjustCanvasResolution(canvas) {

    // Define a base size (e.g., 512x512)
    const baseSize = 512;

    const ratio = 3;

    canvas.width = canvasSize;
    canvas.height = canvasSize;

    // Scale the context
    const ctx = canvas.getContext("2d");
    ctx.scale(2, 2);

    console.log(`Canvas size set to ${canvas.width}x${canvas.height}`);
  }


  // This function will attempt to initialize as soon as possible
  function tryInitialize() {
    if (document.readyState === 'loading') {
      // DOM not ready, add event listener
      document.addEventListener('DOMContentLoaded', initializeModelViewer);
    } else {
      // DOM is ready, call the function directly
      initializeModelViewer();
    }
  }

  async function exportGLB() {
    const modelViewer = getModelViewer();
    const glTF = await modelViewer.exportScene();

    // create filename based on current datetime
    const filename = `export-${new Date().toISOString().replace(/:/g, "-")}.glb`;
    const file = new File([glTF], filename);
    try {
      sendFileToDart(file);
    } catch (error) {
      console.error("Error exporting model:", error);
      const link = document.createElement("a");
      link.download = file.name;
      link.href = URL.createObjectURL(file);
      link.click();
    }
    console.log("Exported model");
  }

  function sendFileToDart(file) {
    if (ExportModel) {
      // TODO: 
      console.log('Sending file to Dart');
    }
    const reader = new FileReader();
    reader.onload = function (event) {
      const base64data = event.target.result.split(',')[1]; // Remove data URL prefix
      const fileData = {
        name: file.name,
        type: file.type,
        size: file.size,
        lastModified: file.lastModified,
        content: base64data
      };
      // Assuming you're using flutter_inappwebview
      ExportModel.postMessage(JSON.stringify(fileData));
    };
    reader.readAsDataURL(file);
  }

  // Call tryInitialize immediately
  tryInitialize();
</script>
